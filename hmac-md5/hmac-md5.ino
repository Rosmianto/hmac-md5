byte msg[] = { 0x01, 0x00, 0x00, 0x92, 0x26, 0x65, 0xbf, 0xac, 0x3c, 0x32, 0x76, 0x77, 0xd4, 0xfb, 0xbd, 0x97,
	           0xcd, 0xb3, 0x12, 0x33, 0x01, 0x12, 0x61, 0x65, 0x67, 0x69, 0x73, 0x32, 0x40, 0x75, 0x69, 0x69,
	           0x2e, 0x61, 0x63, 0x2e, 0x69, 0x64, 0x04, 0x06, 0x7f, 0x00, 0x00, 0x01, 0x1f, 0x13, 0x30, 0x32,
	           0x2d, 0x30, 0x30, 0x2d, 0x30, 0x30, 0x2d, 0x30, 0x30, 0x2d, 0x30, 0x30, 0x2d, 0x30, 0x31, 0x0c,
	           0x06, 0x00, 0x00, 0x05, 0x78, 0x3d, 0x06, 0x00, 0x00, 0x00, 0x13, 0x06, 0x06, 0x00, 0x00, 0x00,
	           0x02, 0x4d, 0x18, 0x43, 0x4f, 0x4e, 0x4e, 0x45, 0x43, 0x54, 0x20, 0x31, 0x31, 0x4d, 0x62, 0x70,
	           0x73, 0x20, 0x38, 0x30, 0x32, 0x2e, 0x31, 0x31, 0x62, 0x4f, 0x17, 0x02, 0x00, 0x00, 0x15, 0x01,
	           0x61, 0x65, 0x67, 0x69, 0x73, 0x32, 0x40, 0x75, 0x69, 0x69, 0x2e, 0x61, 0x63, 0x2e, 0x69, 0x64,
	           0x50, 0x12, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	           0x00, 0x00 };

byte key[] = { 0x58, 0x69, 0x72, 0x6b, 0x61, 0x42, 0x53, 0x49, 0x55, 0x49, 0x49, 0x32, 0x30, 0x31, 0x38 };

byte result[16];

void setup() {
	Serial.begin(115200);
	Serial.println("HMAC-MD5 Test");
	hmac_md5(key, sizeof(key), msg, sizeof(msg), result);

	// -------------- DEBUGGING PURPOSE ------------------
	for(int i = 0; i < 16; i++) {
		byte b = result[i];
		if(b < 0x10) Serial.print('0');
		Serial.print(b, HEX); Serial.print(' ');
	}
	// -------------- DEBUGGING PURPOSE ------------------
}

void loop() {

}

void hmac_md5(byte key[], int keyLength, byte msg[], int msgLength, byte result[]) {

	int blockSize = 64;
	byte baKey[64] = { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	                   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	                   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	                   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 };
	byte hash_result[16];
	byte baOuterKeyPadded[blockSize];
	byte baInnerKeyPadded[blockSize];
	byte tempHash[16];
	MD5Builder md5;

	if(keyLength > blockSize) {
		md5.begin();
		md5.add(key, keyLength);
		md5.calculate();
		md5.getBytes(baKey);
	}
	else {
		for(int i = 0; i < keyLength; i++) {
			baKey[i] = key[i];
		}
	}

	for (int i = 0; i < blockSize; i++) {
		baOuterKeyPadded[i] = baKey[i] ^ 0x5C;
		baInnerKeyPadded[i] = baKey[i] ^ 0x36;
	}

	// return hash(o_key_pad ∥ hash(i_key_pad ∥ message)) // Where ∥ is concatenation
	md5.begin();
	md5.add(baInnerKeyPadded, blockSize);
	md5.add(msg, msgLength);
	md5.calculate();
	md5.getBytes(tempHash);

	md5.begin();
	md5.add(baOuterKeyPadded, blockSize);
	md5.add(tempHash, 16);
	md5.calculate();
	md5.getBytes(hash_result);

	memcpy(result, hash_result, 16);
}